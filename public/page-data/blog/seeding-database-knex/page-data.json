{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/seeding-database-knex","result":{"data":{"markdownRemark":{"html":"<p>I was looking for a way to put data in my database. I wanted something that was\norganized and simple like a Rails migration, but also agreed with Node. To my\nsuprise, NPM didnâ€™t have many of packages to choose from. I considered\nSerialize, but wound up using <a href=\"http://knexjs.org/\">Knex</a> which made migrations a\npiece of cake.</p>\n<p>Weâ€™ll be seeding a database in this post, but Knex is a fully functioning query\nbuilder. It handles migrations and schema changes with elegance. If you want to\ngive it a spin you can try out some queries. Otherwise, letâ€™s get started.</p>\n<h2>Setting Up Knex</h2>\n<p>Open your command line application. Once youâ€™ve cdâ€™d into your project install\nKnex by running the following:</p>\n<pre><code class=\"language-bash\">npm install knex --save\n</code></pre>\n<p>Now that knex is installed weâ€™re ready to generate a template knexfile.js by running:</p>\n<pre><code class=\"language-bash\">knex init\n</code></pre>\n<p>This command creates a knexfile.js in your project. All your database\nconfigurations are housed in this file. There are different blocks for your\ndevelopment, staging and production configs which reduces some environment\ncomplexities. Youâ€™ll probably want to use environment variables if you plan on\npushing this to production. Otherwise, youâ€™ll be fine just hardcoding your\nconnection data. Below you can see how mine looks.</p>\n<h2>Configuring Knex</h2>\n<pre><code class=\"language-js\">module.exports = {\n  development: {\n    client: 'postgresql',\n    connection: 'postgresql://localhost/your_database\n  },\n  production: {\n    client: 'postgresql',\n    connection: {\n      host: 'your_hostâ€™,\n      database: â€™your_database_nameâ€™,\n      user: â€˜your_database_userâ€™',\n      password: 'your_database_passwordâ€™\n    },\n    pool: {\n      min: 2,\n      max: 10\n    },\n    migrations: {\n      tableName: 'knex_migrations'\n    }\n  }\n}\n</code></pre>\n<h2>Creating a Table Migration</h2>\n<p>Once youâ€™ve added your database config values we can create our first migration.\nLetâ€™s run a command to create a table. In this example, we will set up a users\ntable. Run the following from the command line.</p>\n<pre><code class=\"language-bash\">knex migrate:make create_users_table\n</code></pre>\n<p>You should see a new folder called migrations. Inside this folder youâ€™ll have a\nfile named <code>create_users_table</code>. Weâ€™ll specify our columns in this file shortly.\nBut first Iâ€™d like to point out the long number at the beginning of the file\nname. In short, this number allows the files to be run in the order they were\ngenerated, which prevents nasty foreign key errors. Yay!</p>\n<p>Letâ€™s take a look inside the new <code>create_users_table</code> file we generated. Youâ€™ll\nnotice an exports up and exports down. The exports up will hold the code that\ncreates the table and the exports down will house the code that deletes the\ntable. Now letâ€™s write some code inside these sections.</p>\n<pre><code class=\"language-js\">exports.up = function (knex, Promise) {\nreturn Promise.all([\n  knex.schema.createTable('users', function (table) {\n    table.increments('id').notNullable().primary()\n    table.boolean('active')\n    table.timestamp('created_at').defaultTo(knex.fn.now())\n    table.string('email').notNullable().unique()\n    table.string('first_name').notNullable()\n    table.string('last_name').notNullable()\n    table.timestamp('updated_at').defaultTo(knex.fn.now())\n  })\n])\n}\nexports.down = function (knex, Promise) {\n  return knex.schema.dropTable('users')\n}\n</code></pre>\n<h3>Running Our Table Migration</h3>\n<p>Itâ€™s important to note that code to generate our users table is javascript, but\nwill be interpreted as SQL when we run the migration. In my opinion JS is easier\nto read than a straight SQL migration. Especially since Knex allows us to use\nmethods like notNullable() and defaultTo() and unique(). So with these few lines\nof JavaScript we can generate or delete our table entirely from the command line.</p>\n<p>Now that we have the migration written running it only takes a few keystrokes.\nMake sure your database is started and run the following command:</p>\n<pre><code class=\"language-bash\">knex migrate:latest\n</code></pre>\n<h3>Creating Our Seed File</h3>\n<pre><code class=\"language-bash\">knex seed:make add_users\n</code></pre>\n<p>This will give us a file sort of similar to the first one we generated. Instead\nof an exports up and down, this file will just contain a seed export. Letâ€™s move\non and write some code to make our users.</p>\n<pre><code class=\"language-js\">exports.seed = function(knex, Promise) {\n// Deletes ALL existing entries\nreturn knex('users').del()\n  .then(function () {\n    // Inserts seed entries\n    return knex('users').insert([\n      {\n        active: true,\n        created_at: knex.fn.now(),\n        email: bugsbunnyboi@example.com',\n        first_name: 'Bugs',\n        last_name: 'Bunny',\n        updated_at: knex.fn.now()\n      },\n      {\n        active: true,\n        created_at: knex.fn.now(),\n        email: 'yosemitesammy@example.com',\n        first_name: 'Yosemite',\n        last_name: 'Sam',\n        updated_at: knex.fn.now()\n      },\n      {\n        active: true,\n        created_at: knex.fn.now(),\n        email: 'marvinthemarty@example.com',\n        first_name: 'Marvin',\n        last_name: 'Martian',\n        updated_at: knex.fn.now()\n      },\n    ])\n  })\n}\n</code></pre>\n<h3>Running Our Seed File</h3>\n<p>This code will insert three users to our database. Letâ€™s try it out by doing:</p>\n<pre><code class=\"language-bash\">knex seed:run\n</code></pre>\n<h3>We Seeded Our DB with Knex</h3>\n<p>If all goes as planned we should have three new users ðŸŽ‰. As you can see, Knex\nis designed to keep migrations tidy. In turn this simplifies schema changes and\neliminates foreign key conflicts. All in all that means more time to code features.</p>","frontmatter":{"date":"February 05, 2018","path":"/blog/seeding-database-knex","title":"Seeding a Database with Knex"}}},"pageContext":{}}}